apex_directive:
  id: "SCG-EDGEBIND-STALL-V1.0"
  name: "Edge Binding Stall Mitigation for Phase 7"
  version: "1.0.0"
  status: "active"
  created_at_utc: "2025-11-24T00:00:00Z"
  author: "Only SG Solutions - SCG Substrate Group"
  classification: "Concurrency | Topology | Adversarial"

  objective:
    summary: >
      Eliminate stalls during rapid edge binding under adversarial load by
      enforcing batched write semantics, adding timing instrumentation, and
      converting silent hangs into explicit, logged failures.

    problem_statement: >
      During Phase 7 Test 41 (Rapid edge binding), the SCG MCP server can stall
      under stress, likely due to lock contention, runaway cycle checks, or
      unbounded synchronous work in the edge binding path. This directive
      standardizes edge binding semantics and introduces stall detection.

  scope:
    systems:
      - "scg-core graph"
      - "scg-mcp-server"
      - "Phase 7 harness (tests 40 to 47)"
    operations:
      - "Edge creation"
      - "Edge binding"
      - "Cycle checks triggered by edge binding"

  invariants:
    concurrency_invariant:
      description: "Edge binding must not deadlock or stall."
      rules:
        - "All edge inserts are performed under a single batched write lock."
        - "No nested lock acquisition is permitted inside edge binding."
        - "No synchronous blocking calls inside async edge binds."

    latency_invariant:
      description: "Edge binding latency must be bounded."
      rules:
        - "Any single edge binding batch must complete within 500 ms."
        - "Phase 7 harness must treat any longer latency as a stall."

    progress_invariant:
      description: "Each edge bind in Phase 7 must emit a forward progress marker."
      rules:
        - "For each stress edge in Test 41, a log and checkpoint must be written."
        - "If no new checkpoint appears within 10 seconds, the harness fails the run."

  implementation_spec:
    graph_edge_binding:
      file: "src/scg_core.rs"
      function_signature: "pub fn bind_edge_batch(&self, specs: Vec<EdgeSpec>) -> Result<Vec<EdgeState>, SCGError>"

      reference_implementation: |
        pub fn bind_edge_batch(
            &self,
            specs: Vec<EdgeSpec>,
        ) -> Result<Vec<EdgeState>, SCGError> {
            use std::time::Instant;

            let started = Instant::now();

            // 1. Validate specs without holding write lock
            //    (ids exist, weights valid, no self edges unless allowed)
            // 2. Take a single write lock for all inserts
            let mut inner = self.inner.write();

            let mut created = Vec::with_capacity(specs.len());

            for spec in specs {
                // Minimal work in the write section
                // Validate nodes exist
                if !inner.nodes.contains_key(&spec.src) || !inner.nodes.contains_key(&spec.dst) {
                    return Err(SCGError::NodeNotFound(spec.src));
                }
                let id = Uuid::new_v4();
                let edge = EdgeState { id, src: spec.src, dst: spec.dst, weight: spec.weight };
                inner.edges.insert(id, edge.clone());
                created.push(edge);
            }

            let elapsed_ms = started.elapsed().as_millis();

            if elapsed_ms > 500 {
                return Err(SCGError::StallDetected {
                    context: "bind_edge_batch exceeded 500 ms".to_string(),
                    elapsed_ms: elapsed_ms as u64,
                });
            }

            Ok(created)
        }

      constraints:
        - "No nested graph.read() calls inside the write section."
        - "No calls to external services or blocking I/O inside bind_edge_batch."
        - "Cycle detection, if present, must use bounded work per edge."

    single_edge_binding:
      file: "src/scg_core.rs"
      function_signature: "pub fn edge_bind(&self, src: Uuid, dst: Uuid, weight: f64) -> Result<EdgeState, SCGError>"

      timing_instrumentation: |
        // Add timing around edge binding
        let started = std::time::Instant::now();
        // ... existing logic ...
        let elapsed_ms = started.elapsed().as_millis();
        eprintln!("[SCG] edge_bind elapsed_ms={}", elapsed_ms);
        if elapsed_ms > 500 {
            return Err(SCGError::StallDetected { ... });
        }

    cycle_detection:
      requirement: "Cycle checks must be bounded and non recursive where possible."
      guidance: |
        fn check_cycle_bounded(&self, from: NodeId, to: NodeId, max_steps: usize) -> Result<bool, SCGError> {
            // bounded BFS or DFS with max_steps limit
        }

      rule:
        - "Any cycle detection path must cap traversal steps."
        - "Cycle detection must never hold a write lock during long traversals."

  phase7_harness_integration:
    file: "tools/scg_cert_phase7_only.ps1"
    requirements:
      - "Wrap Test 41 in a timing and stall detection wrapper."
      - "If no new 'stress.edge.bind.*' checkpoint appears in 10 seconds, mark stall."
      - "On stall, stop the server process, save logs, exit non zero."
      - "Log elapsed time for each edge bind operation."

  certification_criteria:
    - "Test 41 completes with all planned edges bound."
    - "No stall detected by harness stall detector."
    - "bind_edge_batch never exceeds 500 ms in Phase 7 logs."
    - "Governor remains in STABLE state before and after Test 41."
    - "Full Phase 7 (tests 40 to 47) completes under 120 seconds."

  diagnostics_and_logs:
    log_requirements:
      - "Log an entry for each stress edge bound in Test 41."
      - "Log bind_edge_batch latency in ms."
      - "Log any StallDetected errors with context (test id, cycle)."

    example_logs: |
      [DEBUG] [TEST41] Stress edge 3 bound: ff423995...
      [DEBUG] [EDGE] phase7: bind_edge_batch edges=5 elapsed_ms=3
      [DEBUG] [GOVERNOR] phase7 - cycle=41 context=post_edge_binding nodes=15 edges=9 drift=0 status=STABLE

  failure_modes:
    - id: "F1"
      name: "Deadlock"
      description: "Process CPU drops to near zero and no further logs appear."
      response:
        - "Mark Phase 7 as uncertified."
        - "Inspect lock usage around edge binding."
    - id: "F2"
      name: "Spin loop"
      description: "CPU at 100 percent with no progress markers."
      response:
        - "Add timing guards and early exit with StallDetected."
    - id: "F3"
      name: "Unbounded cycle detection"
      description: "Cycle checks walk large portions of the graph synchronously."
      response:
        - "Introduce bounded traversal and move heavy checks outside write lock."

  governance:
    applies_to:
      - "All SCG builds that claim Phase 7 readiness."
    ci_policy:
      - "Any change to graph, governor, or MCP handler must run Phase 7 harness."
      - "Any StallDetected event in CI marks the build as non releasable."
